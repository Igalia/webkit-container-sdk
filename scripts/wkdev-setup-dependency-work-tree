#!/usr/bin/bash

[ -f "${WKDEV_SDK}/.wkdev-sdk-root" ] && source "${WKDEV_SDK}/utilities/application.sh" || { echo "Please set \${WKDEV_SDK} to point to the root of the wkdev-sdk checkout."; exit 1; }
init_application "${0}" "Setup SDK dependencies build environment." host-and-container

# Source utility script fragments
source "${WKDEV_SDK}/utilities/prerequisites.sh"
source "${WKDEV_SDK}/utilities/resources.sh"

# nproc is used to determine the number of CPU cores
verify_executables_exist nproc

# Needed for --settings default below
get_default_dependency_settings() { echo "${WKDEV_SDK}/images/wkdev_sdk/custom_built_packages/wkdev-webkit-dependencies.yaml"; }

argsparse_use_option debug        "Enable debug mode for this script"
argsparse_use_option trace        "Enable 'xtrace' mode for this script"
argsparse_use_option =verbose     "Increase verbosity of this script"

argsparse_use_option =work-directory:     "Path to working directory, where a new work tree will be setup" mandatory
argsparse_use_option =packages-directory: "Path to packages directory, where resulting *.deb/*.ddeb packages will be placed"
argsparse_use_option =settings:           "Path to build definitions .yaml settings file" default:$(get_default_dependency_settings) mandatory

argsparse_usage_description="$(cat <<EOF
<< Purpose >>

    Creates a work tree containing all WebKit dependencies, ready to hack.

<< Examples >>

    $ ${application_name} --work-directory \${HOME}/wkdev-local-sdk
EOF
)"

verify_executables_exist gbp shyaml

# Package naming convention.
# Debian package number version format: [epoch:]upstream-version[-debian-revision]
# By convention, we always enforce the presence of a "debian-revision" suffix, that
# encodes the origin of the package and makes it easy to reason about the state of
# the SDK by only inspecting the list of installed packages (e.g. using 'dpkg -l').
#
# Summary: '${package_version_suffix}' indicates the suffix to use for .deb package names.
# +-----------------+--------------------------------------------------------------------+
# | debian-revision | Package origin                                                     |
# +-----------------+--------------------------------------------------------------------+
# | <any>           | System packages                                                    |
# | wkdevsdk1base   | Self-compiled package, during SDK image creation (on host!)        |
# | wkdevsdk2local  | Self-compiled package, during SDK image _usage_ (in container!)    |
# +-----------------+--------------------------------------------------------------------+
#
# '${package_snapshot_number}' is used when creating a snapshot build of the package, as
# fixed snapshot number: 111 for SDK-included packages, and 222 for local package builds.
#
# The string wkdevsdk2local evaluates to a greater version number than wkdevsdk1
# this way we ensure that this packages always have precedence (greater version number)
# In case of doubt you can use the dpkg command as follows to quickly compare Debian versions numbers:
# dpkg --compare-versions '1:3.19.0-ubuntu24wkdevsdk2local~1' 'gt' '1:3.19.0-ubuntu24wkdevsdk1~999' && echo "its greater" || echo "its not greater"
# ---> output of the example above: "its greater"
#
package_snapshot_number=111
package_version_suffix="wkdevsdk1base"
if is_running_in_container; then
    package_snapshot_number=222
    package_version_suffix="wkdevsdk2local"

    verify_executable_exists aptly
fi

process_command_line_arguments() {

    argsparse_parse_options "${@}"
    argsparse_is_option_set "trace" && set -o xtrace

    work_directory="${program_options["work-directory"]}"
    packages_directory="${program_options["packages-directory"]-}"
    settings="${program_options["settings"]}"

    [ -z "${work_directory}" ] && _abort_ "You have to pass a work directory using the --work-directory option."
    [ ! -d "${work_directory}" ] && _abort_ "You have to pass a valid directory to the --work-directory option"

    [ -z "${packages_directory}" ] && packages_directory="${work_directory}/packages"
    [ ! -d "${packages_directory}" ] && mkdir --parents "${packages_directory}" &>/dev/null

    [ -z "${settings}" ] && settings="${dependency_settings}"
    [ ! -f "${settings}" ] && _abort_ "Cannot parse settings file '${settings}', make sure it exists and is accesible."
}

# Replaces ${variable_references} in a template text file by the content, if defined, and writes the result into a new file.
render_template() {

    local template_file_name="${1}"
    local result_file_name="${2}"
    shift 2

    local variable_names=${@}

    local commands=()
    local allowed_variables=""
    for variable_name in ${variable_names}; do
        local key="${variable_name}"
        [[ "${key}" =~ "[@]" ]] && key="${variable_name/\[@\]/}"

        if [ -z "${allowed_variables}" ]; then
            allowed_variables="\${${key}}"
        else
            allowed_variables="${allowed_variables},\${${key}}"
        fi

        local value="${!variable_name}"
        commands+=("export ${key}=\"${value}\"")
    done

    commands+=("$(printf "envsubst '%s'< \"${template_file_name}\" > \"${result_file_name}\"" "${allowed_variables}")")
    printf -v command_string "%s\n" "${commands[@]}"

    if argsparse_is_option_set "debug"; then
        echo ""
        echo "Rendering template '${template_file_name}' to result file '${result_file_name}' applying substitutions:"
        echo "${command_string}"
    fi

    bash -c "${command_string}"
    render_status=${?}

    if argsparse_is_option_set "debug"; then
        echo "Result file:"
        cat "${result_file_name}"
    fi

    return ${render_status}
}

# Main functionality
run() {

    process_command_line_arguments "${@}"

    # Ensure we stop on unchecked error or undefined variable
    set -eu -o pipefail

    echo ""
    echo "-> Create work tree in '${work_directory}' directory..."
    mkdir --parents "${work_directory}/sources" &>/dev/null
    mkdir --parents "${work_directory}/builds" &>/dev/null

    apt_repository_name="$(get_custom_package_local_apt_repository_name)"
    if is_running_in_container; then
        show_output=$(aptly repo show "${apt_repository_name}" 2>/dev/null)
        aptly_status=${?}
        echo ""
        if [ ${aptly_status} -ne 0 ]; then
            echo "-> Create local APT repository '${apt_repository_name}'..."
            aptly repo create -distribution="$(get_custom_package_distribution)" -component="$(get_custom_package_component)" "${apt_repository_name}"
        else
            echo "-> Re-using existing local APT repository '${apt_repository_name}'. Statistics:"
            echo "${show_output}"
        fi

        if [ ! -f "$(get_custom_package_local_apt_repository_source_list)" ]; then
            echo "deb [trusted=yes] file:///${apt_repository_name}/public/ $(get_custom_package_distribution) $(get_custom_package_component)" | sudo tee "$(get_custom_package_local_apt_repository_source_list)" >/dev/null
        fi
    else
        echo ""
        echo "-> Local APT repository creation disabled -- we are running on the host, not in the container where this is useful."
    fi

    # NOTE: If you define variables here as 'local' using the keyword 'declare', then take into account that declaration and assignment must
    # be separate statements when the assignment value is provided by a command substitution. The exit code from the command substitution is
    # not propagated because bash first does the assignment and the proceeds to mark the variable as local or with the declared type, so the
    # return code in that case is always zero, because is the return code of setting the variable to local or with the declared type.
    # And that breaks the purpose of using "set -e" above. See: https://stackoverflow.com/q/4421257
    # Since this code is on the main() function of the program, declaring local variables here has little effective purpose, as local
    # variables are also visible to children functions in bash. So is easier to just use standard/global variables here.
    package_groups=()
    package_groups_count=$(cat "${settings}" | shyaml --quiet get-length package_groups)
    for (( package_group_index=0; package_group_index<${package_groups_count}; package_group_index++ )); do
        package_group_name=$(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.name)
        package_group_entities_count=$(cat "${settings}" | shyaml --quiet get-length package_groups.${package_group_index}.entities)
        package_groups+=("${package_group_name}")

        echo ""
        echo "-> Processing package group '${package_group_name}' containing ${package_group_entities_count} packages:"

        # Create package group directories
        mkdir --parents "${work_directory}/sources/${package_group_name}" &>/dev/null
        mkdir --parents "${work_directory}/builds/${package_group_name}" &>/dev/null

        packages_in_group=()
        for (( package_group_entity_index=0; package_group_entity_index<${package_group_entities_count}; package_group_entity_index++ )); do
            package_name=$(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.name)
            packages_in_group+=("${package_name}")

            package_url=$(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.url)

            # Get optional parameters (shyaml cmd is allowed to fail)
            gbp_import_dsc_options=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.gbp_import_dsc || true))
            [ -z ${gbp_import_dsc_options+x} ] && gbp_import_dsc_options=""
            deb_build_options=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.deb_build || true))
            [ -z ${deb_build_options+x} ] && deb_build_options=""
            debuild_options=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.debuild || true))
            [ -z ${debuild_options+x} ] && debuild_options=""
            dpkg_buildpackage_options=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.dpkg_buildpackage || true))
            [ -z ${dpkg_buildpackage_options+x} ] && dpkg_buildpackage_options=""

            dependencies_count=$(cat "${settings}" | shyaml --quiet get-length package_groups.${package_group_index}.entities.${package_group_entity_index}.depends_on || true)
            [ -z "${dependencies_count}" ] && dependencies_count=0

            system_dependencies_count=$(cat "${settings}" | shyaml --quiet get-length package_groups.${package_group_index}.entities.${package_group_entity_index}.required_system_packages || true)
            [ -z "${system_dependencies_count}" ] && system_dependencies_count=0

            echo ""
            echo "  -> Processing package '${package_name}' with URL '${package_url}':"
            echo "     Options:"
            echo "     - gbp_import_dsc_options=\"${gbp_import_dsc_options[@]}\""
            echo "     - deb_build_options=\"${deb_build_options[@]}\""
            echo "     - debuild_options=\"${debuild_options[@]}\""
            echo "     - dpkg_buildpackage_options=\"${dpkg_buildpackage_options[@]}\""

            # Create directories for result files and dependency packages
            build_directory="${work_directory}/builds/${package_group_name}/${package_name}"
            mkdir --parents "${build_directory}"

            # Prepare gbp.conf configuration file
            # NOTE: Remember that paths are resolved within the 'wkdev_package_builder' container rootfs.
            # The work directory - ${work_directory} within this script - is bind-mounted to '/builder/work'
            # within the 'wkdev_package_builder' container (see images/wkdev_package_builder/invoke-build-package.sh).
            # Therefore export_directory needs to start with '/builder/work' and follow the same directory naming scheme.
            export_directory="/builder/work/builds/${package_group_name}/${package_name}"
            package_distribution="$(get_custom_package_distribution)"

            echo ""
            gbp_conf_parameters=(package_distribution export_directory debuild_options[@] dpkg_buildpackage_options[@])
            render_template "$(get_template_file_by_name "gbp.conf")" "${build_directory}/gbp.conf" ${gbp_conf_parameters[@]} || _abort_ "Template creation failed"

            export GBP_CONF_FILES="${build_directory}/gbp.conf"
            export DEBFULLNAME="$(get_sdk_maintainer_name)"
            export DEBEMAIL="$(get_sdk_maintainer_email)"

            gbp_verbose_flag=""
            argsparse_is_option_set "debug" && gbp_verbose_flag="--verbose" # Not a typo: --debug should enable --verbose for gbp, which shows all Git commands it executes...

            # Create package source directory
            mkdir --parents "${work_directory}/sources/${package_group_name}/${package_name}" &>/dev/null
            pushd "${work_directory}/sources/${package_group_name}/${package_name}" &>/dev/null

            # Create a local git repository to manage the package + patches on top
            echo "    -> Creating local Git repository based on DSC file '${package_url}'..."
            run_command_silent_unless_verbose gbp import-dsc ${gbp_verbose_flag} ${gbp_import_dsc_options[@]} "${package_url}" || _abort_ "Git repository creation failed"

            package_git_directory=$(find . -type d -name "*${package_name}*" | head --lines 1)
            pushd "${package_git_directory}" &>/dev/null || _abort_ "Switching to '${package_git_directory}' failed"

            # Override debian revision in package version string
            # NOTE: Neither '--local <x>' nor '--distribution <y>' can be set via gbp.conf -- only a command line parameter to gbp dch.
            echo "    -> Creating snapshot of package using a fixed snapshot number '${package_snapshot_number}' and an additional package name suffix '${package_version_suffix}'..."
            run_command_silent_unless_verbose gbp dch ${gbp_verbose_flag} --local "${package_version_suffix}" --distribution "${package_distribution}" --commit --snapshot --snapshot-number "${package_snapshot_number}" --debian-branch "ubuntu/${package_distribution}" || _abort_ "Incrementing local package version failed"
            popd &>/dev/null

            dependencies_file="${build_directory}/.dependencies"
            touch "${dependencies_file}" &>/dev/null

            # Handle 'depends_on' field to depend on all build artifacts (.deb/.ddeb) files of a previously built package.
            if [ ${dependencies_count} -gt 0 ]; then
                for (( dependency_index=0; dependency_index<${dependencies_count}; dependency_index++ )); do
                    dependency_package_name=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.depends_on.${dependency_index}))
                    echo "    -> Mark this package depending on the expression '${dependency_package_name}' provided by earlier builds."

                    echo "${dependency_package_name}" >> "${dependencies_file}"
                done
            fi

            # Handle 'required_system_packages' field to depend on system packages.
            if [ ${system_dependencies_count} -gt 0 ]; then
                for (( system_dependency_index=0; system_dependency_index<${system_dependencies_count}; system_dependency_index++ )); do
                    system_dependency_package_name=($(cat "${settings}" | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.required_system_packages.${system_dependency_index}))
                    echo "    -> Mark this package depending on the system package '${system_dependency_package_name}' provided in the distribution repositories."

                    echo "${system_dependency_package_name}" >> "${dependencies_file}"
                done
            fi

            echo "    -> Generating Makefile for package '${package_name}' in '${build_directory}/Makefile'..."
            makefile_parameters=(apt_repository_name deb_build_options[@] work_directory package_group_name package_name packages_directory)
            render_template "$(get_template_file_by_name "Makefile.package")" "${build_directory}/Makefile" ${makefile_parameters[@]} || _abort_ "Template creation failed"
            popd &>/dev/null
        done

        build_directory="${work_directory}/builds/${package_group_name}"
        echo ""
        echo "-> Generating Makefile for package group '${package_group_name}' in '${build_directory}/Makefile'..."
        packages="${packages_in_group[@]}"
        makefile_parameters=(apt_repository_name packages packages_directory)
        render_template "$(get_template_file_by_name "Makefile.group")" "${build_directory}/Makefile" ${makefile_parameters[@]} || _abort_ "Template creation failed"
    done

    build_directory="${work_directory}/builds"
    echo ""
    echo "-> Generating Makefile for all package groups in '${build_directory}/Makefile'..."
    echo "   NOTE: Use 'make' / 'make install' in '${build_directory}' to build all packages in all package groups or descend into a specific package group or single package to build exactly what's needed for the current task."

    packages="${package_groups[@]}"
    makefile_parameters=(apt_repository_name packages packages_directory)
    render_template "$(get_template_file_by_name "Makefile.group")" "${build_directory}/Makefile" ${makefile_parameters[@]} || _abort_ "Template creation failed"

    echo ""
    echo "-> Finished."
    echo "NOTE: Remember to 'make repo-publish' once before installing one or multiple packages using 'make install'."
}

run "${@}"
