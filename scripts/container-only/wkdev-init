#!/usr/bin/env bash

[ -z "${WKDEV_SDK}" ] && export WKDEV_SDK=/wkdev-sdk
[ -f "${WKDEV_SDK}/.wkdev-sdk-root" ] && source "${WKDEV_SDK}/utilities/application.sh" || { echo "Please set \${WKDEV_SDK} to point to the root of the wkdev-sdk checkout."; exit 1; }
init_application "${0}" "Performs post-container-startup initialization tasks." container-only

# Source utility script fragments
source "${WKDEV_SDK}/utilities/debian-packages.sh"
source "${WKDEV_SDK}/utilities/podman.sh"

argsparse_use_option trace        "Enable 'xtrace' mode for this script"

argsparse_use_option =shell:      "Specific shell to use for interactive container usage" mandatory
argsparse_use_option =user:       "Container account user name" type:username mandatory
argsparse_use_option =group:      "Container account group name" type:group mandatory
argsparse_use_option =packages:   "Additional packages to install"


argsparse_usage_description="$(cat <<EOF
<< Purpose >>

    ${application_name} is the entry point for the wkdev-sdk container.

    It performs various initialization tasks, such as installing the user shell package in the container,
    updating the APT cache, setting up sudo support, etc.

    NOTE: You do NOT need to call this script manually, it is only used during container startup.
EOF
)"

process_command_line_arguments() {

    argsparse_parse_options "${@}"
    argsparse_is_option_set "trace" && set -o xtrace

    container_shell="${program_options["shell"]}"
    container_user_name="${program_options["user"]}"
    container_group_name="${program_options["group"]}"
    additional_packages="${program_options["packages"]-}"
}

try_update_apt_cache() {

    echo ""

    echo "[1/10] Updating APT repositories..."
    if is_first_time_run; then
        update_packages || _abort_ "Cannot update APT repositories"
    else
        # Do not _abort_ unless this is the first time the container is entered. apt-get may fail if there is no internet connectivity on the host, but we still want to enter.
        update_packages || _log_ "Cannot update APT repositories (continuing)"
    fi
}

try_install_shell_package() {

    echo ""

    container_shell_package=$(basename "${container_shell}")
    if is_package_installed "${container_shell_package}"; then
        echo "[2/10] No need to install user shell package '${container_shell_package}' - it's already present."
    else
        echo "[2/10] Installing user shell package '${container_shell_package}'..."
        ensure_package_installed "${container_shell_package}"
    fi
}

try_install_additional_packages() {

    echo ""
    if [ -z "${additional_packages}" ]; then
        echo "[3/10] No need to install additional packages - none necessary."
        return 0
    fi

    echo "[3/10] Installing additional packages '${additional_packages}', if necessary..."
    for package in ${additional_packages}; do
        if is_package_installed "${package}"; then
            echo "      Skipping '${package}' - it's already present."
        else
            echo "      Installing '${package}'..."
            ensure_package_installed "${package}"
        fi
    done
}

try_switch_shell_for_user() {

    echo ""

    if ! grep "${container_user_name}" /etc/passwd | grep --quiet "${container_shell}"; then
        echo "[4/10] Switch shell to '${container_shell}' for container user '${container_user_name}'..."
        usermod --shell "${container_shell}" "${container_user_name}" || _abort_ "Cannot switch shell: executing 'usermod' failed"
    else
        echo "[4/10] No need to switch shell to '${container_shell}' - it's already the default for user '${container_user_name}'."
    fi
}

try_setup_setgid_subuid_files() {

    echo ""

    if ! grep --quiet "${container_user_name}" /etc/subuid; then
        echo "[5/10] Setup /etc/sub{gid|uid} files for user '${container_user_name}'..."
        echo ""

        # FIXME: This assumes the host UID/GID subordinate range is 100000-200000. We should rather
        # find a free subordinate-range in the given host outer container mapping, to assign it
        # within the "outer container" /etc/sub?id files, defining the used mapping when spawning
        # podman containers ("inner container") from the "outer container" session.
        # Eventually the new 'auto' user-ns mode can be handy for this kind of situation to avoid
        # having to define a mapping at all in the outer container -- in theory podman should
        # be able to figure out exactly this 'free' subordinate-range. Needs some testing.
        usermod --add-subuids 50000-99999 --add-subgids 50000-99999 "${container_user_name}" || _abort_ "Cannot add user '${container_user_name}' to /etc/subgid or /etc/subuid file: executing usermod failed"
    else
        echo "[5/10] No need to setup /etc/sub{gid|uid} -- UID/GID mapping for container user '${container_user_name}' already present."
    fi

    echo "      -> /etc/subgid contents: $(cat /etc/subgid)"
    echo "      -> /etc/subuid contents: $(cat /etc/subuid)"
}

try_setup_sudoers_file() {

    echo ""

    local sudoers_directory="/etc/sudoers.d"
    local sudoers_file="${sudoers_directory}/sudoers"
    echo "[6/10] Setup sudoers file '${sudoers_file}' for user '${container_user_name}', if necessary..."

    mkdir --parents "${sudoers_directory}" &>/dev/null
    chmod 750 "${sudoers_directory}"

    [ ! -f "${sudoers_file}" ] && touch "${sudoers_file}"

    # Suppress FQDN checks upon sudo invocation
    if ! grep --quiet "Defaults !fqdn" "${sudoers_file}"; then
        echo "Defaults !fqdn" >> "${sudoers_file}"
    fi

    # Ensure passwordless sudo is set up for user
    if ! grep --quiet "${container_user_name} ALL = (root) NOPASSWD:ALL" "${sudoers_file}"; then
        echo "${container_user_name} ALL = (root) NOPASSWD:ALL" >> "${sudoers_file}"
    fi
}

try_setup_run_user_directory() {

    echo ""

    local container_user_id=$(id --user --real "${container_user_name}")
    local current_run_user_directory="/run/user/${container_user_id}"
    echo "[7/10] Initialize systemd-style /run/user/ user session directory '${current_run_user_directory}', if necessary..."

    mkdir --parents "${current_run_user_directory}" &>/dev/null
    chmod 700 "${current_run_user_directory}"
    chown "${container_user_name}:${container_group_name}" "${current_run_user_directory}" &>/dev/null
}

try_setup_dockerenv_file() {

    echo ""

    echo "[8/10] Create /.dockerenv file to make 'bwrap' detection work in legacy Epiphany/cog versions..."
    sudo touch /.dockerenv
}

try_setup_local_sdk_repository() {

    echo ""

    local packages_directory="/wkdev-sdk-packages"
    echo "[9/10] Initialize local '${packages_directory}' APT repository, if necessary..."

    mkdir --parents "${packages_directory}" &>/dev/null
    chmod 750 "${packages_directory}"
    chown "${container_user_name}:${container_group_name}" "${packages_directory}" &>/dev/null
}

try_setup_permissions_jhbuild_directory() {

    echo ""

    local jhbuild_directory="/jhbuild"
    echo "[10/10] Setup jhbuild '${jhbuild_directory}' directory permissions..."

    chown --recursive "${container_user_name}:${container_group_name}" "${jhbuild_directory}" &>/dev/null

}

# Main functionality
run() {

    process_command_line_arguments "${@}"

    # Set for the whole wkdev-init session.
    export DEBIAN_FRONTEND=noninteractive

    echo "-> Performing post-startup initialization tasks in container..."
    try_update_apt_cache
    try_install_shell_package
    try_install_additional_packages
    try_switch_shell_for_user
    try_setup_setgid_subuid_files
    try_setup_sudoers_file
    try_setup_run_user_directory
    try_setup_dockerenv_file
    try_setup_local_sdk_repository
    try_setup_permissions_jhbuild_directory

    # Reset DEBIAN_FRONTEND again.
    unset DEBIAN_FRONTEND

    echo ""
    echo "Finished initialization"

    if [ -x "$HOME/.wkdev-firstrun" ]; then
        echo ""
        echo "Executing $HOME/.wkdev-firstrun"
        su "${container_user_name}" --group="${container_group_name}" --login --command="$HOME/.wkdev-firstrun"
    fi

    echo ""
    echo "Sleeping forever..."

    touch "$(get_init_done_file)"
    exec tail -f /dev/null
}

run "${@}"
