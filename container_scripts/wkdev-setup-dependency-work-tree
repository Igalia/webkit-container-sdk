#!/usr/bin/bash
application_path=${0}
application_name=$(basename ${application_path})
application_directory=$(cd "$(dirname "${application_path:-$PWD}")" 2>/dev/null 1>&2 && pwd)
sdk_directory=$(readlink -f "${application_directory}/..")
printf "${application_name}: Setup SDK dependencies build environment.\n"

# Verify pre-requisite: shyaml needs to be installed.
if ! command -v shyaml > /dev/null; then
    printf "Cannot find 'shyaml' executable.\n"
    exit 1
fi

# Verify pre-requisite: git-buildpackage needs to be installed.
if ! command -v gbp > /dev/null; then
    printf "Cannot find 'gbp' executable.\n"
    exit 1
fi

if [ -f "/run/.containerenv" ]; then
    # Verify pre-requisite: aptly needs to be installed.
    if ! command -v aptly > /dev/null; then
        printf "Cannot find 'aptly' executable.\n"
        exit 1
    fi
fi

# Command line argument handling - defaults.
trace=0
verbose=0
work_directory=""
settings=""

apt_repository_name="wkdev-sdk-packages"
apt_repository_source_list="/etc/apt/sources.list.d/${apt_repository_name}.list"
container_image_name="docker.io/nikolaszimmermann/wkdev-sdk"
dependency_settings="${sdk_directory}/dependencies/wkdev-dependencies.yaml"
package_makefile_template="${sdk_directory}/dependencies/Makefile.package.template"
group_makefile_template="${sdk_directory}/dependencies/Makefile.group.template"

# Command line argument handling - help message.
show_help_message() {
    cat << EOF
<< Purpose >>

    Creates a work tree containing all WebKit dependencies, ready to hack.

<< Usage >>

    $ ${application_name} (options)?

    See below for a list of possible options.

    Example:

    $ ${application_name} --workdir \${HOME}/wkdeps
    ...

<< Options >>

    -h / --help:        show this help message
    -t / --trace:       enable tracing for bash script
    -v / --verbose:     increase verbosity for ${application_name}

    -w / --workdir:     path to work directory in which the new work tree will be setup
    -s / --settings:    path to settings file in YAML format (default: ${dependency_settings})
EOF
}

parse_command_line_arguments() {
    while :; do
        case ${1} in
            -h | --help)
                show_help_message
                exit 0
                ;;
            -t | --trace)
                trace=1
                shift
                ;;
            -v | --verbose)
                verbose=1
                shift
                ;;
            -w | --workdir)
                if [ -n "${2}" ]; then
                    work_directory="${2}"
                    shift 2
                else
                    shift
                fi
                ;;
            -s | --settings)
                if [ -n "${2}" ]; then
                    settings="${2}"
                    shift 2
                else
                    shift
                fi
                ;;
            -*)
                printf "Invalid option '${1}'.\n"
                show_help_message
                exit 1
                ;;
            *)
                break ;;
        esac
    done

    trap '[ "$?" -ne 0 ] && printf "[ERROR] A fatal error occurred. Aborting!\n"' EXIT
}

handle_command_line_arguments() {
    # Bash scripting recommendations
    set -o errexit # Exit upon command failure
    set -o nounset # Warn about unset variables

    # Enable tracing, if desired.
    if [ ${trace} -eq 1 ]; then
        set -o xtrace
    fi

    if [ -z "${work_directory}" ]; then
        printf "You have to pass a work directory using the --workdir option.\n"
        exit 1
    fi

    if [ ! -d "${work_directory}" ]; then
        printf "You have to pass a valid directory to the --workdir option.\n"
        exit 1
    fi

    if [ -z "${settings}" ]; then
        settings="${dependency_settings}"
    fi

    if [ ! -f "${settings}" ]; then
        printf "Cannot parse settings file '${settings}', make sure it exists and is accesible.\n"
        exit 1
    fi
}

# Main functionality
run() {
    parse_command_line_arguments $@
    handle_command_line_arguments

    printf "\n-> Create work tree in '${work_directory}' directory...\n"
    mkdir -p "${work_directory}/sources" &>/dev/null
    mkdir -p "${work_directory}/builds" &>/dev/null

    local packages_directory="${work_directory}/packages"
    mkdir -p "${packages_directory}" &>/dev/null

    if [ -f "/run/.containerenv" ]; then
        printf "\n-> Create local APT repository '${apt_repository_name}'...\n"
        aptly repo create -distribution=kinetic -component=main "${apt_repository_name}"

        if [ ! -f "${apt_repository_source_list}" ]; then
            echo "deb [trusted=yes] file:///${apt_repository_name}/public/ kinetic main" | sudo tee "${apt_repository_source_list}" >/dev/null
        fi
    else
        printf "\n-> Local APT repository creation disabled -- we are running on the host, not in the container where this is necessary.\n"
    fi

    local package_groups=()
    local package_groups_count=$(cat ${settings} | shyaml --quiet get-length package_groups)
    for (( package_group_index=0; package_group_index<${package_groups_count}; package_group_index++ )); do
        local package_group_name=$(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.name)
        local package_group_entities_count=$(cat ${settings} | shyaml --quiet get-length package_groups.${package_group_index}.entities)
        package_groups+=("${package_group_name}")
        printf "\n-> Processing package group '${package_group_name}' containing ${package_group_entities_count} packages:\n"

        # Create package group directories
        mkdir -p "${work_directory}/sources/${package_group_name}" &>/dev/null
        mkdir -p "${work_directory}/builds/${package_group_name}" &>/dev/null

        local packages_in_group=()
        for (( package_group_entity_index=0; package_group_entity_index<${package_group_entities_count}; package_group_entity_index++ )); do
            local package_name=$(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.name)
            packages_in_group+=("${package_name}")

            local package_url=$(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.url)
            local dget_options=($(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.dget))
            local gbp_dsc_options=($(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.gbp_dsc))
            local debuild_options=($(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.options.debuild))

            local dependencies_count=$(cat ${settings} | shyaml --quiet get-length package_groups.${package_group_index}.entities.${package_group_entity_index}.depends_on)
            if [ -z "${dependencies_count}" ]; then
                dependencies_count=0
            fi

            local system_dependencies_count=$(cat ${settings} | shyaml --quiet get-length package_groups.${package_group_index}.entities.${package_group_entity_index}.required_system_packages)
            if [ -z "${system_dependencies_count}" ]; then
                system_dependencies_count=0
            fi

            # Create package source directory
            printf "\n  -> Processing package '${package_name}' with URL ${package_url}:\n"
            mkdir -p "${work_directory}/sources/${package_group_name}/${package_name}" &>/dev/null
            pushd "${work_directory}/sources/${package_group_name}/${package_name}" &>/dev/null

            # Download DSC file
            printf "\n    -> Downloading dsc file from URL '${package_url}' (dget options: '${dget_options[@]}')...\n"
            if [ ${verbose} -eq 0 ]; then
                dget ${dget_options[@]} --quiet --download-only "${package_url}" &>/dev/null
            else
                dget ${dget_options[@]} --download-only "${package_url}"
            fi

            # Change epoch to a fixed value of 666, to indicate our packages.
            dsc_file=$(ls -1 *${package_name}*.dsc | head --lines 1)
            old_version=$(grep "^Version:" "${dsc_file}")
            sed --in-place --expression 's/^Version: \([0-9.]*:\)\?\(.*\)/Version: 666:\2/' "${dsc_file}"
            new_version=$(grep "^Version:" "${dsc_file}")

            printf "\n    -> Injected debian package epoch '666:' prefix for the package version in the dsc file, to assure they are prefered over system packages of the same name/version.\n"
            printf "       Old version: ${old_version}\n"
            printf "       New version: ${new_version}\n"

            # Create a local git repository to manage the package + patches on top

            printf "\n    -> Importing package in local Git repository (gbp-dsc options: '${gbp_dsc_options[@]}')...\n"
            if [ ${verbose} -eq 0 ]; then
                gbp import-dsc ${gbp_dsc_options[@]} *${package_name}*.dsc &>/dev/null
            else
                gbp import-dsc ${gbp_dsc_options[@]} *${package_name}*.dsc
            fi

            # Create directories for result files and dependency packages
            local result_directory="${work_directory}/builds/${package_group_name}/${package_name}"
            mkdir -p "${result_directory}"

            local dependencies_file="${result_directory}/.dependencies"
            touch "${dependencies_file}" &>/dev/null

            # Handle 'depends_on' field to depend on all build artifacts (.deb/.ddeb) files of a previously built package.
            if [ ${dependencies_count} -gt 0 ]; then
                for (( dependency_index=0; dependency_index<${dependencies_count}; dependency_index++ )); do
                    local dependency_package_name=($(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.depends_on.${dependency_index}))
                    printf "    -> Mark this package depending on the expression '${dependency_package_name}' provided by earlier builds.\n"

                    echo "${dependency_package_name}" >> "${dependencies_file}"
                done
            fi

            # Handle 'required_system_packages' field to depend on system packages.
            if [ ${system_dependencies_count} -gt 0 ]; then
                for (( system_dependency_index=0; system_dependency_index<${system_dependencies_count}; system_dependency_index++ )); do
                    local system_dependency_package_name=($(cat ${settings} | shyaml --quiet get-value package_groups.${package_group_index}.entities.${package_group_entity_index}.required_system_packages.${system_dependency_index}))
                    echo "    -> Mark this package depending on the system package '${system_dependency_package_name}' provided in the distribution repositories."

                    echo "${system_dependency_package_name}" >> "${dependencies_file}"
                done
            fi

            printf "    -> Generating Makefile for package '${package_name}' in '${result_directory}/Makefile'...\n"
            cat "${package_makefile_template}" | apt_repository_name="${apt_repository_name}" debuild_options="${debuild_options[@]}" sdk_directory="${sdk_directory}" work_directory="${work_directory}" package_full_name="${package_group_name}/${package_name}" packages_directory="${packages_directory}" envsubst '${apt_repository_name},${debuild_options},${sdk_directory},${work_directory},${package_full_name},${packages_directory}'> "${result_directory}"/Makefile
            popd &>/dev/null
        done

        local result_directory="${work_directory}/builds/${package_group_name}"
        printf "\n-> Generating Makefile for package group '${package_group_name}' in '${result_directory}/Makefile'...\n"
        cat "${group_makefile_template}" | apt_repository_name="${apt_repository_name}" packages="${packages_in_group[@]}" packages_directory="${packages_directory}" envsubst '${apt_repository_name},${packages},${packages_directory}'> "${result_directory}"/Makefile
    done

    local result_directory="${work_directory}/builds"
    printf "\n-> Generating Makefile for all package groups in '${result_directory}/Makefile'...\n"
    printf "   NOTE: Use 'make' / 'make install' in '${result_directory}' to compile/install all packages in all package groups or descend into a specific package group or single package to build exactly what's needed for the current task.\n"
    cat "${group_makefile_template}" | apt_repository_name="${apt_repository_name}" packages="${package_groups[@]}" packages_directory="${packages_directory}" envsubst '${apt_repository_name},${packages},${packages_directory}' > "${result_directory}"/Makefile

    printf "\n-> Finished.\n"
    printf "NOTE: Remember to 'make repo-publish' once before installing one or multiple using 'make install'.\n"
}

run ${@}
