#!/bin/sh

application_path=${0}
application_name=$(basename ${application_path})
printf "${application_name}: Initialize wkdev-sdk container...\n"
printf "Timestamp: $(date)\n"

container_shell=${1}
container_user_name=${2}

# Prevent to run this script from the host
if [ ! -f /run/.containerenv ]; then
    printf "\nThe script '${application_name}' is intended to run from within the container only.\n"
    exit 1
fi

# 1) Install same shell that current host user uses.
container_shell_package=$(basename "${container_shell}")
if [ $(dpkg-query -W -f='${Status}' ${container_shell_package} 2>/dev/null | grep -c "ok installed") -eq 0 ]; then
    printf "\n-> Installing user shell package '${container_shell_package}'...\n"
    apt-get update && apt-get --assume-yes install ${container_shell_package} && apt-get --assume-yes autoremove && apt-get --assume-yes clean
else
    printf "\n-> No need to install user shell package '${container_shell_package}' - it's already present.\n"
fi

# 2) Setup /etc/subgid and /etc/subuid to allow spawning rootless containers from within the container.
printf "\n-> Setup /etc/subgid and /etc/subuid files for user '${container_user_name}'...\n\n"

# FIXME: This assumes the host UID/GID subordinate range is 100000-200000. We should rather
# find a free subordinate-range in the given host -> outer container mapping, to assign it
# within the "outer container" /etc/sub?id files, defining the used mapping when spawning
# podman containers ("inner container") from the "outer container" session.
# Eventually the new 'auto' user-ns mode can be handy for this kind of situation to avoid
# having to define a mapping at all in the outer container -- in theory podman should
# be able to figure out exactly this 'free' subordinate-range. Needs some testing.
usermod --add-subuids 50000-99999 --add-subgids 50000-99999 ${container_user_name}
if [ ${?} -ne 0 ]; then
    printf "Cannot add user '${container_user_name}' to /etc/subgid or /etc/subuid file: executing usermod failed.\n"
    exit 1
fi

printf "   /etc/subgid contents: $(cat /etc/subgid)\n"
printf "   /etc/subuid contents: $(cat /etc/subuid)\n"

container_shell=$(which ${container_shell_package})
printf "\n-> Switch shell for container user '${container_user_name}' to '${container_shell}'...\n"
usermod --shell ${container_shell} ${container_user_name}

# 3) Setup sudo support (useful enough for sudo apt-get install...)
printf "\n-> Allow passwordlesss sudo for user '${container_user_name}'...\n"
mkdir -p /etc/sudoers.d &>/dev/null
touch /etc/sudoers.d/sudoers &>/dev/null

# Suppress FQDN checks upon sudo invocation
if ! grep -q 'Defaults !fqdn' /etc/sudoers.d/sudoers; then
    printf "Defaults !fqdn\n" >> /etc/sudoers.d/sudoers
fi

# Ensure passwordless sudo is set up for user
if ! grep -q "${container_user_name} ALL = (root) NOPASSWD:ALL" /etc/sudoers.d/sudoers; then
    printf "%s ALL = (root) NOPASSWD:ALL\n" "${container_user_name}" >> /etc/sudoers.d/sudoers
fi

# 4) Hand-create /run/user/<uid> with correct permissions, since we are not using systemd
#    inside the container, to provide a login service, that usually takes care of this job.
current_run_user_directory="/run/user/$(id --user --real ${container_user_name})"
mkdir -p ${current_run_user_directory} &>/dev/null
chmod 700 ${current_run_user_directory}
chown ${container_user_name} ${current_run_user_directory} &>/dev/null

# 5) Create place for SDK internal APT repository
packages_directory=/wkdev-sdk-packages
mkdir ${packages_directory} &>/dev/null
chmod 750 ${packages_directory}
chown ${container_user_name} ${packages_directory} &>/dev/null

# 6) Rest forever
printf "\n-> Finished initialization - sleeping forever...\n"
printf "   Timestamp: $(date)\n"

touch /run/.wkdev-init-done
exec tail -f /dev/null
